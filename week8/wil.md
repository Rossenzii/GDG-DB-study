# 트랜잭션 처리와 복구
원자성: 트랜잭션과 관련된 작업은 모두 실행 또는 모두 실패해야 함

일관성: 데이터가 정해진 규칙(제약 조건, 무결성)을 만족하는 상태를 유지해야 함

격리성: 트랜잭션 간 간섭 없이 수행돼야 함

지속성: 트랜잭션 커밋 후 db의 상태는 시스템이 중단, 정전, 장애 발생해도 그대로 유지돼야 함

잠금 매니저: 리소스의 동시 접근 제어, 데이터 무결성 보장
- 역할 
1) 리소스의 동시 접근 제어: 트랜잭션이 같은 데이터에 접근 시 충돌 방지
2) 데이터 무결성 보장: 동시에 수정 또는 읽는 작업으로 인해 잘못된 데이터가 저장되지 않도록 함

- 동작 과정
1) 잠금 요청 시 동작: 트랜잭션이 리소스를 사용하기 위해 잠금 요청
2) 해당 리소스를 다른 트랜잭션이 이미 잠금하고 있는지, 어떤 종류의 잠금(공유/배타적)이 걸려 있는지 확인
3) 접근 허용 여부 결정: 요청한 트랜잭션에게 접근 권한이 있으면 잠금 허용 ex) 두 트랜잭션이 동시에 공유 잠금 요청 시 허용
접근 권한이 없으면 잠금 대기하거나 중단 후 재시도 해야 함 ex) 한 트랜잭션이 배타적 잠금을 갖고 있으면 다른 트랜잭션은 대기

- 배타적 잠금
: 동시에 하나의 트랜잭션만 소유 가능, 다른 트랜잭션은 대기/재시도해야 함
주로 데이터 수정 시 사용함

- 잠금 해제 후 처리
: 트랜잭션이 커밋 또는 롤백이 끝나면 잠금 해제
잠금 해제 시 Lock manager는 다른 트랜잭션에게 잠금이 풀렸음을 알려줌 

- 잠금의 종류
공유 잠금: 읽기 + 동시에 여러 트랜잭션 소유 가능
배타적 잠금: 쓰기 + 동시에 한 트랜잭션만 소유 가능

## 버퍼 관리
**페이지 캐시**
: 디스크의 데이터를 메모리에 올려놓는 것으로 디스크 접근을 줄여 성능을 높인다.
데이터베이스는 디스크(영구 저장소)가 느리기 때문에, 속도가 빠른 메인 메모리(RAM)를 중간 계층으로 사용해 데이터를 임시로 저장한다.

1) 메모리 안에 있는 디스크 페이지 복사본을 **가상 디스크**라고 부름
2) 메모리에 원하는 페이지가 없으면, 디스크에서 읽어 메모리에 올리는 것을 **물리적 접근**이라고 한다.
3) 페이지 캐시(또는 버퍼 풀)는 운영체제나 DBMS에서 공통적으로 사용되는 개념으로, 디스크 I/O 성능을 높인다.
4) 디스크에서 읽은 페이지를 메모리에 캐시해두고, 시스템 장애나 재부팅 시 사라진다.

- 역할
1) 디스크의 데이터를 메모리에 복사해둠.
2) 디스크에 저장된 페이지를 읽을 때, 변경 사항을 함께 관리한다. (버퍼링)
3) 메모리에 여유 공간이 없으면, 일부 페이지를 페이지아웃시켜야 한다.
4) 사용하지 않는 페이지는 메모리에서 반환된다.
5) 새로운 페이지를 메모리에 추가할 공간이 없으면, 기존 페이지를 지우거나 디스크에 쓰고 비우며 이를 **플러시**라고 함
6) 아직 디스크로 저장되지 않은 변경된 페이지를 **더티 페이지**라고 함

**커널 페이지 캐시 우회 기법**
많은 DB 시스템은 **O_DIRECT 플래그**를 사용해 커널 페이지 캐시를 우회하고 디스크에 직접 접근한다.
이유) DBMS가 자체적으로 캐시를 관리하는 것이 효율적이기 때문.

리눅스 개발자 리누스 토발즈는 O_DIRECT 사용을 비판적으로 본다.
이유) 동기 방식이고, 미리 읽기를 지원하지 않으며 커널이 액세스 패턴을 학습할 수 없기 때문.

하지만 OS가 효율적 매커니즘을 제공하지 않는다면, 결국 DB는 O_DIRECT를 계속 써야 함
**fadvise**를 사용하면 커널에게 캐시에서 페이지를 비우거나 유지하라고 힌트를 줄 수 있다.
하지만 커널이 그 요청을 따르지 않을 수도..

**메모리 매핑**: I/O 호출을 피할 수 있으나, 커널의 캐시 방식을 제어할 수는 없다.

## 캐싱
1) 스토리지 엔진과 페이지 캐시
스토리지 엔진이 특정 페이지를 요청하면, 우선 캐시된 버전이 있는지 확인하고 반환한다.
없으면 논리적 페이지 주소 또는 페이지 번호를 이용해 디스크에서 물리적으로 읽어와 메모리로 복사 후 반환한다.
이때 메모리로 복사된 페이지를 **참조 상태** 라고 한다.

2) 페이지 고정 

페이지를 고정하면 페이지 캐시에서 제거되지 않는다.

고정되지 않은 페이지는 공간 부족 시 다른 페이지로 교체될 수 있다.

교체 시 더티 페이지는 디스크로 쓰고 제거해야 한다.

참조 상태에 있으면 디스크에 쓰기 전 제거할 수 없다.

3) 페이지 캐시 만료
: 캐시된 데이터가 많아질수록 디스크 접근을 줄일 수 있지만, 캐시 공간은 한정적이다.
새 페이지 저장이 필요하면 오래된 페이지 제거 필요하다. 
변경되지 않은 페이지는 바로 제거 가능하지만, 더티 페이지 는 디스크로 동기화 후 제거해야 한다.
디스크 flush는 성능 저하 유발 → 일부 DBMS는 백그라운드 프로세스로 주기적으로 flush 수행 (예: PostgreSQL의 background flush writer)

4) 지속성(데이터 손실 방지)
데이터 손실 방지를 위해 체크포인트 프로세스가 주기적으로 동작:
WAL 로그와 페이지 캐시 싱크 맞춤 + checkpoint 완료 시점까지 더티 페이지 제거 불가

5)  페이지 캐시 관리의 trade-off
디스크 접근 횟수 줄이기 위해 flush 시점을 늦춘다.
더티 페이지를 우선 flush → 빠르게 캐시에서 제거 가능하다.
제거할 페이지를 잘 선택해 최적의 순서로 flush 하는 것이 중요하다.

## 페이지 고정
- 페이지 고정
: 모든 읽기/쓰기 작업은 디스크 I/O가 동반되지만, 디스크 I/O는 느리기 때문에 시스템은 가능한 한 디스크 접근을 최소화하려고 한다.

B-트리처럼 상위 레벨 노드가 여러 쿼리에서 반복적으로 읽히는 경우: 상위 레벨 노드는 메모리에 올려 두는 것이 효율적이다.

-> 상위 레벨 노드는 캐시에 고정하거나 자주 쓰이는 노드는 paging 하지 않고 유지한다.

페이지 고정의 장점)
1) 디스크 접근 횟수를 줄여서 성능이 향상된다.
2) 자주 접근되는 페이지를 메모리에 계속 두면 디스크 I/O가 줄어든다.
3) 연속된 쓰기/삭제 작업에서 같은 노드를 반복 접근할 때도 효과적이다.


- pre-fetching와 즉시 만료
프리페치(pre-fetching)
: 예측해서 미리 페이지를 읽어들이는 것으로 순차 접근 시 효과적이다.

즉시 만료
: PostgreSQL은 순차 스캔 시 circular buffer로 접근 후 버퍼를 즉시 만료시켜 재활용성을 높인다.

## 페이지 교체 알고리즘
- 페이지 교체가 필요한 이유
메모리 공간은 한정적 → 새로운 페이지를 담으려면 기존 페이지를 일부 내보내야 한다.
요청 확률이 낮은 페이지부터 교체하는 것이 원칙적 목표이다.

교체 정책) 요청 확률이 낮은 페이지를 교체, 재요청되지 않을 페이지를 예측해 교체하려는 시도가 필요하다.

- 교체 알고리즘 종류
1) FIFO 
: 가장 먼저 캐시에 들어온 페이지를 먼저 교체한다.
순서만 고려하고, 참조 빈도는 반영이 안 된다.
단점: 최근에 참조된 페이지라도 오래되었다면 교체 대상이 될 수 있다.

2) LRU
: 최근 가장 적게 사용된 페이지부터 교체하며 재요청 확률이 낮다고 가정한다. 
2Q LRU: 두 개의 큐 사용 -> 첫 큐) 새로 들어온 페이지 (임시 보관), 두 번째 큐) 자주 요청된 페이지
첫 큐에서 재참조된 페이지만 두 번째 큐로 승격 → 노이즈 제거한다.

3) CLOCK 알고리즘
LRU 대안으로 많이 사용한다.
구조) 단순하고 캐시 친화적이며 순환 버퍼(원형 버퍼) 구조이다.
페이지마다 접근 여부를 나타내는 비트(혹은 카운터)를 기록한다.

작동 방식) 버퍼를 순회하며, 접근 비트가 0인 페이지를 교체 대상으로 선택한다.
비트가 1이면 0으로 초기화하고 건너뛴다. 0이면 해당 페이지를 제거 대상으로 선정하고 만료작업을 스케쥴링 한다.
CLOCK-SWEEP: 원형 버퍼를 쭉 순회하며 비트를 검사한다.
원형 버퍼의 장점: 클럭 포인터와 페이지를 비교하고 스왑 방식으로 쉽게 수정 가능하다.

4) LFU
: 페이지가 참조 요청 빈도가 낮은 페이지를 제거한다.
TinyLFU: 페이징 시점이 아닌 요청 빈도를 고려해 페이지의 만료 여부를 결정한다. 캐시 접근 이력을 빈도수 히스토그램에 저장한다.
등록 큐(LRU 알고리즘 기반으로 새로 추가된 페이지 저장), 관찰 큐(제거될 확률이 높은 페이지 저장), 보호 큐(큐에 오래 남아 있을 페이지 저장)

특징)
요청 빈도가 높은 페이지는 보호 큐로 이동해 제거 확률이 낮다
요청 빈도가 낮은 페이지는 제거 확률이 높다.