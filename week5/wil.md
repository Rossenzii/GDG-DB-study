## 페이지 구조

DB system: 데이터 레코드를 데이터 파일 & 인덱스 파일로 저장한다.

파일: 여러 file system block을 합친 고정 크기의 페이지로 구성됨

B-트리노드: 키&데이터 레코드 쌍을 저장하는 리프 노드, 키&다른 노드를 가리키는 포인터를 저장하는 비 리프노드로 구성됨

페이지: 키, 값, 자식 페이지를 카리키는 포인터로 이루러진 triplet 구조임

## 슬롯 페이지

가변 길이 레코드 저장 시: 삭제된 레코드들의 공간을 회수하는 공간 관리가 어려움

페이지 포맷: 최소한의 overhead로 가변 길이 레코드 저장, 삭제된 record의 메모리 회수, 페이지의 record를 정확한 위치에 상관없이 참조해야 함

1. 슬롯 페이지를 통해 문자열, 블랍 같은 가변 길이 자료형을 효율적으로 저장 가능함

[용어 정리]

페이지: 디스크나 메모리에서 데이터를 저장하는 고정 크기 블록 / 셀: 하나의 레코드(행 데이터) / 슬롯: 보통 포인터들이 나열된 배열 구조, 셀을 직접 담기보다 셀의 위치 정보만 가짐

페이지: 슬롯 or 셀의 집합임(페이지 앞부분에는 포인터 배열 (슬롯 배열), 페이지 뒷부분에는 실제 데이터 (셀들)),

페이지 내 독립적인 영역에 pointer & cell을 분리해서 저장 -> 레코드의 논리적 순서는 셀을 가리키는 포인터의 순서로 제어함

2. 슬롯 페이지에는 페이지 & 셀에 대한 중요한 정보를 담는 고정 길이의 헤더가 있음, (셀: 키, 포인터, 레코드 등 임의의 데이터를 저장)

슬롯 헤드는 다음 조건을 모두 충족함

: 오버헤드 최소화, 공간 회수 (by 단편화 제거 & 페이지 재구성), 동적 레이아웃 (ID를 통해 page 외부에서 접근하기 때문에 정확한 위치는 page 내부에서만 필요함)

## 셀구조

: 셀 병합 -> 페이지, 페이지 병합 -> 트리

키 셀: 구분 키 & 자식 페이지로 가는 포인터임 / 셀 종류&키 길이& 셀이 가리키는 자식 페이지의 ID & key byte 수가 들어감 / 내부 노드에서 사용함

키 값 셀: 키 & 헤당 데이터 레코드를 저장함 / 셀 종류&키 길이&값 길이&키 바이트&데이터 레코드 바이트가 들어감 / 리프 노드에서 사용함


## 셀 병합으로 슬롯 페이지 구성

페이지의 셀은 오른쪽에, 셀 오프셋 & 포인터는 왼쪽에 추가함

키는 삽입 순서대로 추가, 셀 오프셋 포인터는 키 순서대로 저장하면 논리적 순서를 유지할 수 있음 -> 셀을 삽입 or 업데이트 or 삭제해도 재배치가 필요 없음

## 가변 길이 데이터 관리

 페이지 레코드 삭제 시 실제로 셀을 지우고 다른 셀을 옮기는 대신 삭제된 셀이라고 표시하고 메모리에 저장된 사용 가능 목록에 회수된 메모리 크기와 해당 위치를 가리키는 포인터를 업데이트 함. 사용 가능 목록에는 사용할 수 있는 세그먼트의 크기&위치 저장

 SQLite: 사용 중이지 않는 세그먼트를 프리블록이라고 함, 첫번째 프리블록을 가리키는 포인터를 페이지 헤더에 저장함 -> 새로운 레코드를 한 페이지에 저장할 수 있는지 빠르게 판단하도록 페이지에 남아있는 바이트 수를 저장함

 세그먼트 전략

 - 최초 적합: 첫 번째로 찾은 적합한 세그먼트 선택, but 오버헤드 발생 가능

 - 최적 적합: 레코드를 저장할 수 있는 가장 작은 세그먼트 선택

 B-트리는 단순한 계층형 포인터로 구성됨, 페이지 식별자로 트리 파일에서 자식 노드를 찾고 셀 오프셋으로 페이지에서 셀을 찾을 수 있음

 ##  버전 관리

 아파치 카산드라는 파일명의 접두사에 버전을 기록함 

 버전 4.0 이후 데이터 파일명: na-1-bigData.db처럼 na로 시작, 4.0 이전 버전의 접두사는 ma이다.

 버전을 개별 파일에 기록하기도 함 ex) PostgreSQL은 PG_VERSION 파일에 버전 정보를 기록함

 인덱스 파일 헤더에 버전을 명시하기도 함 -> 헤더의 버전 정보는 반드시 모든 버전에서 읽을 수 있게 인코딩 필요

 ## 체크섬

 : 소프트웨어 버그와 하드웨어 장애 발생으로 파일이 손상될 시 사전에 파악하고 다른 sub-system에 전파되는 것을 방지하는 역할을 함

 보장성이 매우 낮고 다중 비트 오류를 감지할 수 없음, 대부분 XOR & parity 검사 & 합을 사용함

일반적으로 page 단위로 체크섬을 계산하고 페이지 헤더에 저장함

 CRC: 버스트 오류를 감지할 수 있음, 룩업 테이블과 다항식의 나눗셈을 사용함

 데이터 변조 여부 확인 용도로 암호화 해시 함수를 사용해야 함, CRC는 데이터가 의도하지 않은 우발적인 방법으로 변경됐는지 확인하므로 의도적인 데이터 변경 감지에는 적합하지 않음

## 요약

기본형 데이터를 직렬화해 셀을 만들고 셀을 병합해 슬롯 페이지를 구성하는 방법에 대한 챕터임

슬롯 페이지 포맷은 페이지 외부에서 cell ID를 통해 개별 cell에 접근할 수 있다. 삽입 순서대로 record를 정리하지만 cell offset을 정렬해 키 순서를 보존하는 구조임