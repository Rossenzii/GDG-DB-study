## 직렬화 가능성
1) 트랜잭션: DB의 상태를 읽고 쓰는 작업&비즈니스 로직으로 구성됨

2) 스케줄: 트랜잭션을 수행하는 데 필요한 작업의 목록

올바른 스케줄: 동시에 여러 트랜잭션을 실행할 때라도 결과가 트랜잭션을 순서대로 실행한 것과 같아야 한다 (직렬 가능하다)

직렬 스케줄: 모든 트랜잭션이 교차하지 않고 완전히 독립적으로 수행될 수 있는 스케쥴

## 트랜잭션 격리
1) 격리 수준: 트랜잭션이 변경한 내용 중 어떤 부분을 언제 다른 트랜잭션에서 접근할 수 있는지 정의함, 동시에 수행되는 트랜잭션이 고립된 정도와 수행 중에 발생할 수 있는 이상 현상이 발생할 수 있는지를 나타냄

2) 읽기 이상 현상
- 더티 읽기: 아직 commit 안 된 다른 트랜잭션이 결과를 읽는 현상 ex) T1이 주소를 업뎃, T2는 T1이 커밋하기 전에 업뎃된 주소를 읽음 -> T1 실패하고 롤백 시 T2는 커밋되지 않은 값을 읽음

- 반복 불가능 읽기: 트랜잭션이 동일한 row를 2번 쿼리했을 때 둘의 결과가 다른 현상이 나타남 ex) T1이 읽은 row를 T2가 수정하고 커밋 -> T1이 같은 row를 다시 쿼리하면 이전 값과 다른 값을 반환

- 팬텀 읽기: 여러 row를 2번 쿼리했을 때 결과가 다른 현상, 반복 불가능 읽기와 유사하지만 대상이 범위 쿼리(특정 data-record가 아닌 일정 범위의 레코드 조회)임

3) 쓰기 이상 현상
- 갱신 분실: T1, T2가 같은 값 v를 수정할 떄 발생 (T1, T2가 각각 V를 수정하면 서로의 존재를 모르기 때문에 T2가 덮어쓰고 T1이 갱신한 값은 사라짐)

- 더티 쓰기: 트랜잭션이 commit되지 않은 값을 읽고, 수정, 커밋하는 현상

- 쓰기 치우침: 개별 트랜잭션은 불변 조건을 충족하지만 동시 수행 시 조건이 위반되는 현상 ex) A1 A2 계좌 각각 $100 $150인데 합이 250이어서 각각 $200씩 인출하면 계좌 잔액이 둘 다 음수가 나옴

## 격리 수준

| 격리 수준                | 설명                           | 발생 가능한 문제                      |
| -------------------- | ---------------------------- | ------------------------------ |
| **Read Uncommitted** (커밋 이전 읽기) | 다른 트랜잭션이 아직 커밋 안 한 데이터도 읽어버림 | Dirty Read (더러운 읽기)            |
| **Read Committed** (커밋 이후 읽기)   | 커밋된 데이터만 읽음                  | Non-Repeatable Read (반복 불가 읽기), 팬텀 읽기 |
| **Repeatable Read** (반복 가능 읽기)  | 이미 읽은 데이터는 계속 같은 값만 보여줌      | Phantom Read (팬텀 읽기)           |
| **Serializable**(직렬화 가능 수준)     | 완전히 직렬화된 상태, 트랜잭션끼리 철저히 고립   | 없음 (가장 안전)                     |

1~4에서 아래로 갈수록 격리 수준이 높음

스냅샷 격리: 트랜잭션이 시작될 때의 데이터 상태(스냅샷)를 복사해서 읽고, 트랜잭션이 끝날 때까지 그 복사본만 본다.
트랜잭션이 실행되는 동안 다른 트랜잭션이 한 변경사항은 안 보인다.

특징: 반복 읽기 보장 -> 한 트랜잭션 내에서 똑같은 데이터를 여러 번 읽어도 값이 안 변함, 팬텀 리드는 완전히 방지하지 못함, 쓰기 충돌 발생 가능 -> 트랜잭션 두 개가 서로 같은 데이터를 안 바꾸더라도, 논리적으로 충돌 나는 상황이 생길 수 있음

## 낙관적 동시성 제어
낙관적 동시성 제어: transaction 충돌이 거의 발생하지 않는다고 가정 -> 잠금, blocking-transaction을 사용하지 않고 **결과를 커밋하기 전에 트랜잭션을 검증해** 동시 수행 트랜잭션의 읽기/쓰기 충돌을 방지하고 직렬화 가능성을 확인함

- 읽기 단계: 트랜잭션이 필요한 데이터를 읽고 작업을 수행하는 단계로 잠금(lock)을 걸지 않음

- 검증 단계: 트랜잭션이 끝나기 직전에 다른 트랜잭션이 내가 읽었던 데이터에 변화를 주었는지 검사하는 단계 -> 쿼리한 데이터가 최신이 아니거나 읽기 단계 중에 수정, 커밋한 값을 다른 트랜잭션이 덮어썼으면 컨텍스트를 초기화하고 읽기 단계부터 다시 수행함 

- 쓰기 단계: 검증을 통과한 트랜잭션만 실제로 데이터베이스에 변경 사항을 기록하는 단계 

1. 검증: 이미 커밋된 transaction 또는 현재 검증 중인 transaction과의 충돌 여부를 확인 

2. 트랜잭션 커밋 조건: 두 트랜잭션 T1, T2 가 동시에 존재할 때: T2의 읽기 단계가 시작되기 전에 T1이 커밋하면 → T2도 커밋할 수 있다.

T2의 쓰기 단계가 시작되기 전에 T1이 커밋하고, T1의 쓰기 대상과 T2의 읽기 대상이 겹치지 않으면 → T2는 T1이 쓴 값을 참조하지 않으므로 충돌이 없다.

3. 낙관적 동시성 제어는 검증이 성공적이고 트랜잭션을 재시도할 필요가 없는 경우에 효율적임 (트랜잭션 재시도 시 성능이 저하될 수도 있기 때문)

## 다중 버전 동시성 제어
다중 버전 동시성 제어: 여러 버전의 레코드를 저장하고 단조 증가 transaction-id 또는 timestamp로 식별해 db의 일관성을 보장함

- 가장 마지막에 커밋된 값이 현재 값, 트랜잭션 매니저: 한 번에 최대 하나의 커밋되지 않은 값이 존재하도록 제어
- 잠금, 스케줄링, 2단계 잠금과 같은 충돌 해결 알고리즘 or timestamp 순서화 알고리즘을 사용해 구현함

## 비관적 동시성 제어
비관적 동시성 제어: 충돌이 자주 날 거라고 보고, 미리 잠금을 걸어 막는 방식

대표적 기법: 타임스탬프 순서 알고리즘 

-> 트랜잭션마다 타임스탬프 부여하고 트랜잭션 수행 여부는 더 높은 timestamp가 설정된 트랜잭션의 커밋 여부에 결정됨, 읽고 쓰는 시점마다 max_read_timestamp, max_write_timestamp 갱신

-> max_write_timestamp보다 낮은 timestamp가 설정된 트랜잭션이 값을 요청 시 이미 새로운 버전의 값이 있으므로 허용하면 순서 위반,
max_read_timestamp보다 낮은 쓰기 작업은 뒤에 실행된 읽기 작업과 충돌함

Thomas Write Rule: 이미 새로운 버전이 존재해도 쓰기 허용할 수 있는 규칙

## 잠금 기반 동시성 제어
잠금 기반 동시성 제어: DB 객체에 명시적으로 잠금을 설정하는 비관적 동시성 제어의 한 종류, 경합과 확장성 문제 발생 가능

- 대표적 기법 → 2단계 잠금

확장 단계: 필요한 잠금을 획득, 축소 단계: 잠금을 해제

- 단점: 교착 발생 가능 (두 트랜잭션이 서로 잠금 해제 기다리는 상태)

### 1. 교착 상태
: 여러 트랜잭션이 잠금을 획득하는 과정에서 서로 사용 중인 잠금을 해제하기를 기다리는 상태
- 교착 해결 방법
타임아웃: 일정 시간 넘으면 중단, Wait-for-graph: 트랜잭션 간 대기 관계 그래프로 관리

우선순위 기반 방법: wait-die - 우선순위 낮은 트랜잭션이 죽음(중단), wound-wait - 우선순위 높은 트랜잭션이 낮은 트랜잭션을 중단시킴

### 2. 잠금과 래치

| 구분    | Lock (잠금)       | Latch (래치)            |
| ----- | --------------- | --------------------- |
| 목적    | 트랜잭션 간 동시성 제어   | DB 내부 자료구조 보호         |
| 지속 시간 | 트랜잭션 단위         | 매우 짧음 (순간적)           |
| 대상    | 레코드, 페이지, 테이블 등 | 메모리 자료구조, 버퍼 등        |
| 공유    | 트랜잭션 간 공유 불가    | 같은 트랜잭션 내 스레드 간 공유 가능 |

- 잠금: 동시 수행 트랜잭션을 격리, 스케쥴링하고 DB 상태를 관리하는데 사용

내부 storage 구조와 무관하며 특정 키에 대해 요청할 수 있음, 트리 외부에 따로 저장 및 관리되며 DB 잠금 매니저가 관리함

- 래치: DB 내부 자료구조(예: B-Tree 노드)를 보호하기 위한 짧고 빠른 잠금
페이지 단위로 동시 접근을 방지함, 논리적 무결성과 물리적 무결성 유지, 오버헤드 낮음 → 성능 유지에 필수

### 3. reader-writer 잠금
RW 잠금: 여러 리더가 동시에 데이터를 읽을 수 있게 하되, 쓰기 작업은 반드시 배타적으로 수행되도록 하는 잠금 방식

리더: 읽기만 함, 다른 리더랑 같이 읽어도 안전 -> 공유 잠금

라이터: 데이터를 바꿈, 다른 리더나 라이터가 같이 접근하면 안 됨 -> 배타 잠금


### 4. 바쁜 대기와 큐잉 기법
동시성 제어에서 잠금이나 래치를 얻을 때 두 가지 기법이 있음

i) 바쁜 대기: 스레드가 CPU를 점유한 채 계속 잠금 시도, 반복해서 잠금 얻으려고 루프를 돌며 검사, 단점 → CPU 낭비 심함

ii) 큐잉: 대기 중인 스레드를 **큐**에 등록해 관리, 대표적 방식: compare-and-swap 알고리즘, 큐가 비어 있으면 바로 잠금 얻음, 큐에 다른 스레드가 있으면 자신을 큐에 등록하고 대기, 장점 → CPU 사용량 감소


### 5. 래치 크래빙
: B-Tree 같은 트리 구조 탐색 시 사용, 루트에서부터 리프 노드까지 내려가며 탐색할 때 필요한 모든 래치를 확보하는 기법

목적:트리 탐색 중 구조가 바뀌지 않도록 보장, 동시성 유지

- 래치 크래빙의 기본 원리
루트 노드의 래치 획득, 다음 레벨 노드 탐색 → 쓰기 필요 시 래치 획득, 자식 노드에 충분한 여유 공간이 있고 구조 변화 가능성이 없다면 부모 노드의 래치를 해제, 반대의 경우 부모 노드의 래치를 계속 유지

- 자식 노드 검사

노드 삽입 시: 자식 노드에 여유 있으면 부모 래치 해제, 자식 노드가 가득 찬 상태 → 부모 래치를 유지, 노드 분할 발생 가능성 → 부모 노드 래치를 유지해야 함

### 6. 래치 업그레이드 & 포인터 추적
: 탐색 시 처음부터 배타 잠금을 얻지 않고 **공유 잠금**으로 시작, 필요할 때만 배타 잠금으로 업그레이드

장점: 동시성 향상, 잠금 충돌 감소

예:탐색 도중 노드에 변동이 필요할 때만 배타 잠금으로 승격

### 7. Blink 트리
: B* 트리의 변형으로 노드마다 부모 노드 외에 형제 링크 포인터를 추가, 형제 노드 간에 링크로 연결되어 탐색 중 구조 변동이 일어나도 안정적으로 탐색 가능

- Blink 트리의 장점

: 부모 노드에 대한 잠금을 지속적으로 유지할 필요가 없음, 형제 링크로 새로운 노드 탐색 가능, 교착 상태 방지, 루트 노드 재탐색 비용 절감



