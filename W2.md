## DB 스터디 2주차

### 칼럼형 DBMS vs 로우형 DBMS

필드: 테이블에서 행과 열의 교차점이며 특정 자료형의 단일 값임

칼럼 저장 방식: 테이블을 수직 분할, 로우 저장 방식: 테이블을 수평 분할, Mysql, PostgreSQL에 해당함

- 로우형 데이터 layout

: 한 개의 로우씩 접근하는 경우에 적합함, 공간 지역성을 극대화할 수 있음

디스크와 같은 반영구적 저장 매체에 저장된 데이터는 블록 단위로 접근함 → 한 블록에 모든 칼럼 값을 저장함

여러 사용자의 특정 필드를 읽을 때보다 특정 사용자의 모든 정보를 읽을 때 효율적

- 칼럼형 데이터 layout

: 데이터의 추세, 평균 등을 계산하는 집계 분석 작업에 적합함

조인, 필터링, 다중 로우 집계 등을 위해 튜플을 재구성하기 위해 칼럼 사이의 관계를 정의하는 메타 데이터가 필요함

- 차이점과 최적화 기법

같은 칼럼의 여러 값을 읽으면 캐시 활용도 & 처리 효율성이 증가함

자료형별로 저장하면 압축률이 증가함

로우형: 데이터를 레코드 단위(대부분의 칼럼을 요청할 때)로 접근하고 일반 쿼리와 범위 스캔 요청이 많을 때 적합함

칼럼형: 많은 로우를 스캔하거나 일부 칼럼에 대한 집계 작업이 많을 때 적합함

- 와이드 칼럼 스토어

: 데이터를 다차원 맵으로 표현하고 여러 칼럼을 칼럼 패밀리(같은 자료형의 집합) 단위로 저장함

칼럼 패밀리의 데이터는 로우 형식으로 저장함

웹 테이블이 가장 대표적인 구현 형태임 → 웹 페이지의 내용과 속성의 스냅숏을 시간별로 저장함

역순 URL을 페이지 식별자로 사용하고 시간별로 각 속성의 스냅숏을 생성함

### 데이터 파일 vs 인덱스 파일

DB 시스템이 구현 방식에 맞는 특수한 포맷의 파일을 사용하는 이유

저장 효율성 (데이터 레코드의 저장 오버헤드 최소화)

접근 효율성 (최소한의 단계로 원하는 레코드를 찾음)

갱신 효율성 (디스크 쓰기를 최소화하는 방식으로 레코드 갱신)

DB 시스템은 데이터 레코드를 테이블 형식으로 저장하며 각 테이블을 별도의 파일에 저장함 

→ 각 레코드는 검색키로 찾을 수 있음, 레코드의 위치를 찾기 위해서는 인덱스를 사용함

새로운 레코드와 업데이트된 레코드는 키-값 쌍의 형식으로 저장됨

- 데이터 파일

: 데이터 레코드를 저장함

1. 인덱스 구조형 테이블: 인덱스에 실제 데이터 레코드를 저장함 → 디스크 탐색 횟수 1회 감소 효과

데이터는 키 순서로 정렬되기 때문에 IOT의 범위 스캔은 실제 값을 읽으면서 비교함

1. 힙 구조형 테이블: 레코드를 특정 순서를 따르지 않고 삽입 순서대로 저장함

새로운 페이지가 추가돼도 파일을 재구성하지 않아도 되지만 데이터 검색 시 데이터의 실제 위치를 가리키는 인덱스가 필요함

1. 해시 구조형 테이블: 레코드를 각 키의 해시 값에 해당하는 버킷에 저장함

버킷 내 레코드는 삽입 순서대로 저장하거나 키 순서로 정렬해 조회 속도를 향상시킴

- 인덱스 파일

: 레코드에 대한 메타 데이터를 저장함 → 이를 사용해 데이터 파일에서의 레코드 위치를 찾음

기본 인덱스: 기본키 역할을 할 수 있는 여러 키의 조합에 대한 인덱스

보조 인덱스: 데이터 레코드를 직접 가리키거나 해당 레코드의 기본키를 저장함

클러스터링 인덱스: 실제 데이터 레코드의 정렬 순서와 검색 키의 정렬 순서가 같은 인덱스, 검색 성능이 좋음, 테이블 1개에 1개

비클러스터링 인덱스: 데이터가 다른 파일에 저장돼 있고 인덱스 키를 기준으로 정렬되지 않은 인덱스

- IOT

: 인덱스 정렬 순서대로 데이터를 저장하는 클러스터형 인덱스

- 기본 index를 통한 간접 참조

데이터 레코드를 직접 참조: 디스크 탐색 오버 헤드가 줄어든다 / 단점: 레코드를 갱신하거나 위치를 변경할 때마다 포인터를 수정해야함

기본 인덱스를 통해 간접 참조: 포인터 갱신 비용이 줄어든다 / 단점: 레코드 위치를 찾는 과정이 추가됨

읽기 작업이 많은 워크 로드: 인덱스 개수가 여러 개여도 괜찮음

쓰기 작업이 많은 워크 로드: 인덱스 개수가 많아지면 포인터 갱신에 문제가 생김 → 오프셋 대신 기본 키로 데이터를 간접 참조함

### 버퍼링과 불변성, 순서화

- 버퍼링: 데이터를 디스크에 쓰기 전에 일부를 메모리에 저장함, B-트리 노드에 인메모리 버퍼를 추가해 I/O 비용을 낮추기도 함
- 가변성: 파일 일부를 읽고 갱신한 뒤에 똑같은 자리에 다시 쓸지에 대한 여부를 나타내는 속성

구현: 쓰기 시 복사 - 갱신된 버전의 레코드를 갖고 있는 수정된 페이지를 해당 파일의 새로운 위치에 저장

- 순서화: 디스크 페이지에 데이터 레코드를 키 순서로 저장함

정렬 순서상 인접한 키는 디스크의 연속된 세그먼트에 저장됨