# B-트리 개요

## 이진 탐색 트리
: 정렬된 인메모리 자료구조, 키-값 쌍 검색에 사용됨
각 노드의 키는 왼쪽 서브트리의 모든 노드 키보다 크고 오른쪽 서브 트리의 모든 키보다 작음

## 트리 밸런싱
균형 트리: 노드가 N개 일때 높이가 logN이고 두 서비트리의 높이 차이가 최대 1인 트리
각 노드에는 왼쪽과 오른쪽 2개의 노드 포인터가 있어서 탐색 공간이 평균적으로 절반으로 줄어든다. 
불균형 트리: 최악의 시간 복잡도는 O(N)

## 디스크 기반 스토리지용 트리
이진 탐색트리: 트리의 팬아웃이 낮기 때문에 트리 밸런싱, 노드 재배치, 포인터 갱신이 잦음 → 디스크 기반 자료구조로 적합하지 않음
문제점 1) 지역성 - 노드는 키 순서에 따라 삽입되지 않아 새로운 노드와 부모 노드가 가까이 위치하지 않을 수 있음, 자식 포인터가 여러 다른 disk page를 가리킬 수 있음 
(paged 이진 트리로 일부 해결 가능)
문제점 2) 트리의 높이 - 팬아웃이 낮은 트리 (이진트리, 2-3트리)는 in-memory 자료 구조로는 유용하지만 노드의 크기가 작아 외부 스토리지 저장에는 비효율적임 

디스크 저장에 적합한 트리: 인접한 키의 지역성을 높이기 위한 높은 팬아웃, 디스크 탐색 횟수를 줄이기 위한 낮은 트리 높이

## 디스크 기반 자료 구조
: 메모리에 데이터를 전부 저장할 수 없을 때 주로 사용함
데이터 일부를 메모리에 캐시, 나머지는 디스크에 저장

## 하드 디스크 드라이브
전통적 알고리즘 - 디스크 드라이브
새로운 저장 매체 - 플래시 드라이브, 바이트 단위로 접근하는 비휘발성 메모리를 사용하는 자료 구조
섹터: 디스크의 최소 전송 단위

## 솔리드 스테이트 드라이브
: 물리적으로 움직이는 부품이 없음
비트 → 셀 → 페이지 → 블록 → 플레인 → 다이 →패키지 → SSD

페이지: 읽고 쓸 수 있는 가장 작은 단위, 비어 있는 메모리 셀에만 쓸 수 있음
블록: 삭제할 수 있는 가장 작은 단위
플래시 변환 레이더: 페이지 ID를 실제 위치와 매핑하고 비어있거나 쓰여진 또는 삭제된 페이지를 관리하는 flash memory controller 
가비지 컬렉션도 수행 → 일부 블록에서 이미 사용 중인 페이지가 있으면 해당 페이지를 다른 위치로 옮기고 페이지 ID 매핑도 수정함

## 디스크 기반 자료 구조
가장 작은 작업 단위가 블록이라는 제약 때문에 효율적인 디스크 기반 자료 구조 설계가 어려움 → 블록 전체를 읽어야 블록의 특정 위치를 참조할 수 있음
팬아웃이 높고 높이가 낮을 때 가장 이상적임

## 유비쿼터스 B-트리
B-트리: 검색 항목을 빠르게 찾을 수 있는 계층형 자료구조임, 팬아웃이 높고 높이가 낮음
포인트 쿼리(=조건식 사용)와 범위 쿼리(비교 조건식 사용)를 효율적으로 수행함

## B-트리 계층
점유율: 보유 가능한 노드 용량과 실제로 보유하고 있는 키의 개수의 비율
팬아웃: 각 노드에 저장할 수 있는 최대 키 수, 높으면 트리 구조 변경 비용을 낮출 수 있고 키와 포인터를 같은 블록 또는 연속된 블록에 저장함 → 불필요한 탐색 감소

## B-트리 탐색의 시간 복잡도
1) 블록 전송 횟수: 각 레벨에는 이전 레벨보다 K배 많은 노드가 있고 자식 포인터를 따라가면 탐색 공간이 N의 비율로 감소함 → logkN
2) 비교 횟수: 비교할 때마다 탐색 공간이 절반으로 줄어든다 → log2N

## B-트리 탐색 알고리즘
탐색의 목적: 특정 키(포인트 쿼리, 업데이트, 삭제 시) or 바로 앞 키(범위 스캔, 새로운 노드 삽입)를 찾기

## B-트리 노드 분할
B-트리에 새로운 노드 삽입: 대상 리프를 찾고 삽입할 위치 결정
오버 플로우: 리프 노드에 남은 공간이 없는 노드, 새로운 키를 삽입하려면 노드를 분할해야 함

분할 조건 1) 리프노드일 경우 노드에 최대 N개의 키-값 쌍을 저장할 수 있고 새로운 키-값 쌍 삽입 시 용량이 초과되는 경우
분할 조건 2) 리프노드가 아닐 경우 노드에 최대 N+1개의 포인터를 저장할 수 있고 포인터 추가 시 용량이 초과되는 경우

단계)
1. 새로운 노드 할당
2. 분할 노드 키의 절반을 새로운 노드로 복사
3. 새로운 키를 알맞은 노드에 삽입
4. 분할 노드의 부모 노드에 분할 키와 새로운 노드를 가리키는 포인터를 추가

## B-트리 노드 병합
언더 플로우: 노드에 저장된 값이 너무 적어 형제 노드들을 병합해야하는 상황
키 삭제: 대상 키가 포함된 리프 노드 찾고 삭제

병합 조건 1) 리프노드일 경우 노드에 최대 N개의 키-값 쌍을 저장할 수 있고 두 노드의 총 키-값 쌍의 수가 N보다 작거나 같은 경우
병합 조건 2) 리프가 아닌 노드일 경우 최대 N+1개의 포인터를 저장할 수 있고 두 노드의 포인터 수의 합이 N+1보다 작거나 같은 경우

단계)
1. 모든 키를 오른쪽 노드에서 왼쪽 노드로 복사
2. 부모 노드에서 오른쪽 노드를 가리키는 포인터를 제거
3. 오른쪽 노드를 제거

## 요약
이진 탐색 트리: 복잡도 관점에서는 디스크에 더 적합함 but 팬아웃이 낮고 균형을 맞추기 위한 재배치 & 포인터 업데이트가 자주 발생하므로 디스크에 적합하지 않음
B-트리: 각 노드에 더 많은 키를 저장할 수 있고(팬아웃 증가), rebalancing 작업 빈도가 더 낮음