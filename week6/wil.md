# [4장: B-트리 구현]

## 페이지 헤더
- 탐색과 유지보수, 최적화에 필요한 페이지에 필요한 정보 저장 ex) 플래그, 레이아웃, 셀 개수, 빈공간을 가리키는 상/하한 오프셋
- postgresql: 페이지 크기 & 레이아웃 버전을 헤더에 저장, mysql innodb: 힙 레코드 개수, 레벨, 기타 구조 관련 값 헤더에 저장, sqlite: 셀 개수와 가장 오른쪽 포인터를 헤더에 저장


## 매직 넘버
: 상수 값을 포함하는 multi-byte 블록, 페이지의 종류와 버전의 정보를 포함함
- 검증과 상태 체크에 사용
- 임의의 offset 바이트열이 매직 넘버와 일치할 가능성이 낮음


## 형제 링크
: 좌우에 있는 형제 페이지를 가리키도록 순방향 / 역방향 링크를 저장하는 방식으로 트리를 구현함
- 부모 노드로 거슬러가지 않고 이웃 노드를 바로 참조 가능함
- 단점: 분할, 병합시 이웃 offset도 갱신해야하므로 복잡함 -> 가장 오른쪽 노드가 아닌 노드를 분할 시 오른쪽 형제 노드의 역방향 포인터를 새로운 노드를 가리키도록 수정해야 함
- 형제 링크가 없는 트리는 부모 노드를 반드시 거치기 떄문에 루트까지 올라가는 경우가 발생할 수도 -> 헤더에 형제 링크를 저장해서 같은 레벨의 이전/다음 노드에 빠르게 접근 가능


## 가장 오른쪽 포인터
- B-tree의 구분키의 역할은 서브트리로 분할하고 탐색하는 것 -> 자식 페이지를 가리키는 포인터가 키보다 하나 더 있음
- 구분키 구조: 자식 포인터, 마지막 포인터는 어떤 키와도 연관되지 않기 때문에 따로 저장(sqlite는 이를 헤더에 저장)
- SQLite: 부모 노드의 마지막 포인터를 따로 저장하지 않고, 노드가 분할되면 새로 생긴 오른쪽 노드를 부모의 마지막 포인터로 간주해서 부모를 업데이트함


## 하이키
: 현재 노드의 서브트리에 저장된 가장 큰 키 -> b link-tree라고 함(postgresql에 사용됨)
- 하이키 저장 방식
1) 하이키 없음: 단순히 키들의 범위만 존재, 다음 페이지로 이동하려면 키 비교
2) 하이키 포함: 각 노드에 하이 키를 명시적으로 저장, 다음 페이지로 넘어갈지 판단 가능 -> 구현이 복잡하지만 경계 판단이 빠름, b+ 트리에 쓰임, 하이키를 저장하는 트리는 각 노드에 저장된 키&포인터 개수 동일, 모든 셀에 키-포인터 쌍이 존재


## 오버 플로우 페이지
B-tree 알고리즘에서 모든 노드는 일정 개수의 키를 유지
각 노드에 저장된 값이 크기가 다를 수 있음 -> 이 노드를 저장하는 고정 크기의 페이지에는 남은 공간이 없을 수도 있음
- 인덱스 노드에 데이터를 저장할때 ..
db는 페이지 단위로 데이터를 저장하는데 페이지마다 정해진 최대 크기 (보통 4kb)가 있음

오버 플로우 페이지: 페이지에 데이터가 안 들어갈 때 데이터를 저장하는 보조 저장 공간

- 기본 노드 크기를 넘을 때 발생
한 페이지에 max_payload_size보다 크면 오버플로우 페이지 필요 
기본 페이지에는 record header + payload 일부 저장, 나머지는 오버 플로우 페이지에 저장 -> sqlite 저장 방식

- 오버 플로우 페이지 관리
: 단편화 발생 가능, 새로운 데이터를 쓰기 위한 공간 회수 & 페이지 삭제 필요
첫 오버플로우 페이지 할당 시 해당 페이지의 id를 기본 페이지의 헤더에 저장 필요


## 이진 검색
: 정렬된 배열, 검색키를 인자로 받고 숫자를 반환, 숫자 >0: 해당 키 존재(=배열에서의 위치)

- 삽입 위치: 검색 키보다 첫 번쨰로 큰 값의 위치, 삽입 위치 이후의 모든 원소는 한 자리씩 이동함


## 간접 포인터를 사용한 이진 검색
: 먼저 중간 셀 오프셋을 선택하고 해당 위치의 키&검색 키를 비교해 오/왼쪽 진행 방향 결정


## 분할과 병합
1) 분할: 노드에 더 이상 키를 저장할 수 없을 때, 두 개의 노드로 나누고 부모 노드에 중간 키(승격 키)를 올리는 과정
- 동작 방식: 키 삽입 중, 현재 노드가 가득 차면 → 분할 ->가운데 키를 부모 노드로 승격 -> 나머지 키는 왼쪽/오른쪽 노드로 나누어 저장
- SQLite 특징: 부모 노드의 마지막 포인터는 새로 만들어진 오른쪽 노드를 가리키도록 업데이트됨

2) 병합: 데이터 삭제로 인해 노드의 키 개수가 너무 적어졌을 때, 인접한 형제 노드와 합치는 과정
- 동작 방식:삭제 후 키 개수가 너무 적으면 형제 노드와 병합, 부모 노드에 있던 구분 키도 함께 병합됨, 병합 후 부모 노드도 다시 조정(키 제거)

부모 노드의 분할과 병합, 재배치 과정에서 page id를 포함하는 구분 키가 한 노드에서 다른 노드로 이동 시 갱신해야 함!

일부 트리(wired tiger)에서 형제 포인터 사용으로 발생하는 데드록을 제거하기 위해 leaf-node 탐색에 부모 포인터를 사용하기도..


## 탐색 경로
: 부모 포인터를 저장하는 대신 루트에서 leaf node까지의 경로를 저정하고 경로를 역순으로 순회하는 방법
- postgresql: BTStack이라는 스택에 탐색 경로 저장
- 승격 키를 부모 노드에 올릴 떄...
부모 노드에 공간이 있다면 탐색 경로에 저장된 셀 인덱스(부모 노드에서 자식 노드를 가리키는 포인터가 들어 있는 위치) 위치에 새로운 셀(부모 노드에 새로운 키&포인터를 한 칸 삽입) 추가 
부모 노드에 공간이 없다면 부모 노드도 분할