## B-tree의 변형

### 1) 개요
1. 쓰기 시 복사형 B-트리: B-트리와 유사한 구조이지만 노드 수정, inplace update를 지원하지 않음, 페이지를 복사하고 업데이트한 뒤에 새로운 위치에 저장
2. 지연형 B-트리: 동일한 노드에 대한 연속된 쓰기 작업의 I/O 요청 횟수를 줄이기 위해 수정 내용을 버퍼에 저장
3. FD-트리: LSM 트리와 유사한 버퍼 메커니즘 사용, 작은 크기의 B-트리를 버퍼로 사용하고 가득 차면 불변 형태로 기록함, 수정 사항은 상위 -> 하위 레벨로 전파
4. Bw-트리: B-트리 노드를 추가 전용 방식으로 기록되는 여러 작은 그룹으로 나눔, 여러 노드에 대한 쓰기 작업을 배치단위로 처리: 비용 절감
5. 캐시 비인지형 B-트리: disk 기반 자료 구조를 in-memory 자료 구조처럼 사용함

### 2) 쓰기 시 복사
: 동시 수행 작업의 데이터 무결성을 보장하기 위해 사용하는 방식으로 페이지를 수정하기 전에 내용을 복사해 원본 대신 복사본을 수정한다.
리더: 라이터와 동시 수행중이며 라이터가 작업 중인 수정 페이지에 접근 시 쓰기 작업이 모두 완료될 때까지 대기함

새로운 페이지 계층이 생성되면 최상단 페이지를 가리키는 포인터를 업데이트 함. 

단점: 더 많은 메모리가 필요함, 페이지 전체를 복사하기 때문에 Processor 사용량 증가
장점: 높이가 낮기 때문에 복사 방식의 단순함 

### 2-1) 쓰기 시 복사 구현: LMDB(lightning memory-mapped db)

LMDB)

메모리 맵 기반 DB: 디스크를 메모리에 매핑하여 데이터를 중간 버퍼 없이 곧바로 접근.
단일 레벨 구조이며, 내부적으로 Copy-on-Write 방식을 사용해 데이터를 관리

동작 방식)

1. 쓰기 작업 시작:
root 노드부터 leaf 노드까지, 경로 상의 모든 노드를 복사함. 복사본에만 수정 가함. (원본은 다른 리더들이 계속 읽을 수 있음)

2. 수정 완료 후: 새로운 루트 노드를 생성하고, 그것을 가리키는 포인터만 갱신. 이전 트리는 참조하는 리더가 없으면 바로 해제 및 재사용 가능.

3. 2개의 루트 버전이 존재함: 최신 버전: 현재 쓰기 작업이 반영된 상태 / 커밋될 버전: 아직 쓰기 작업이 완료되지 않았을 수도 있음.

4. 형제 노드 간 포인터가 없음: 순차 탐색 시 부모 노드를 다시 타고 내려가야 함.

5. MVCC 특성: 복사된 노드가 과거 데이터를 그대로 갖고 있기 때문에, 여러 트랜잭션이 동시에 과거 데이터에 접근 가능.

### 3) 노드 업데이터 추상화
디스크 저장 페이지를 memory-map으로 가져온 상태에서 업데이트하려면 직접 수정이 어려움 -> 일반적으로 캐시 버퍼에 올려서 수정, 쓰기 시 복사 또는 랩퍼를 이용해 해결

1. 방식
원본을 직접 수정하지 않고 메모리 상에서 복사본을 수정한 뒤 반영함

캐시 버퍼를 사용해 수정할 페이지를 메모리에 올리고 수정.

수정된 페이지는 다시 저장소에 반영되며, 이때는 메모리 오버헤드 발생 가능.

2. 개선 방식
멀티버전 트리 구조에서 랩퍼 객체를 이용해 페이지를 복사하지 않고 동기화된 버퍼만 갱신.

모든 변경사항은 랩퍼 객체에서 처리한 뒤 실제 디스크에 반영.

덮어쓰기 대신 변경 내용을 저장소에 따로 저장하고, 간접 참조 방식으로 동기화.

### 4) 지연형 B-트리
: 일부 B-트리 구현은 지연을 지원.

데이터를 수정할 때 바로 쓰지 않고 엔트리에 저장했다가 나중에 기록함.

장점: I/O 비용 절감, 동시성 처리 향상.

### 5) 와이드타이어

: Lazy B-트리의 일종으로 각 노드의 페이지 전체를 복사하지 않고, **엔트리** 단위로 관리. 변경 사항은 엔트리 버퍼에 저장한 뒤 커밋 시 반영.

쓰기 작업의 성능 개선을 위해 설계된 구조로, 디스크 페이지를 읽기 전용 페이지와 업데이트 버퍼로 분리함.

특징: MongoDB에서 사용하는 WiredTiger가 대표적인 예시이며 스토리지 엔진의 기본 구조로 사용함

구조: 버퍼 구조가 있어 쓰기 비용을 줄이고 효율적임, 각 페이지는 디스크 페이지 이미지 + 엔트리 버퍼로 구성됨.
디스크에는 클린 페이지로 존재하며, 수정사항은 메모리에 있는 업데이트 버퍼에 저장됨. -> 읽기는 클린 페이지에서, 쓰기는 업데이트 버퍼에 처리됨.

장점: 읽기/쓰기 작업 간 간섭 없음 → 병렬성 증가, 백그라운드에서 버퍼를 병합하므로, 쓰기 작업이 다른 쓰기/읽기 작업을 기다릴 필요 없음.

### 6) 지연 적용형 트리

: 모든 업데이트를 지연시키는 방식의 B-트리 변형으로 각 노드는 자체 버퍼를 가지지 않고, 하위 구조인 서브트리 단위로 버퍼를 유지함.

동작 방식: 업데이트는 루트 → 하위 서브트리로 내려가면서 전달됨, 업데이트가 루트 버퍼에서 일정량 이상 차면 하위 버퍼로 전달 -> 계층적으로 버퍼를 전달하면서, 복수 단계 지연 처리 수행함

특징: 버퍼는 계층적으로 계단식 전파, 위 버퍼 → 하위 버퍼 → 하위 노드로 전달됨, 요청 수를 줄이고 I/O 비용을 줄이며, 병렬성과 쓰기 효율성을 개선함.

### 정리

와이드타이어: 읽기/쓰기를 분리. 클린 페이지 + 업데이트 버퍼 구성. 병렬성 높음.
LA 트리: 업데이트를 루트 → 하위 노드로 계층적 전달. 병합을 지연시켜 효율 개선.

### 7) FD-트리
: 쓰기 성능을 개선한 B-트리 변형으로, 랜덤 쓰기를 줄이기 위한 트리 구조이다. 버퍼링을 통해 데이터를 일시적으로 저장한 뒤, 한 번에 디스크에 쓴다. SSD 환경에서 I/O 작업 수 줄이고, 쓰기 비용 절감이 목적이다.

1. 특징
: 디스크 접근을 줄이기 위해 리프 노드 수준에서 버퍼 레벨을 설정함.

노드 그룹에 버퍼 추가 → 데이터 변경사항을 모아두었다가 한꺼번에 적용함

Head 트리와 Tail 트리 구성: Head: 검색 속도 빠름, Tail: 쓰기 성능 향상에 도움, Tail 트리 크기 증가 시 하위 레벨로 복사되며 트리 병합을 진행함

### 8) 부분적 캐스케이딩

: FD-트리의 탐색 효율을 개선하는 기법으로 여러 레벨에 존재하는 배열들 간 검색 포인터를 공유함으로써 탐색 횟수를 줄인다.

1. 개념
: 전통적 방식으로는 각 레벨마다 이진 탐색을 수행해야 하므로, 총 k번의 탐색 필요하지만 Fractional Cascading은 각 레벨에서 검색한 위치를 다음 레벨로 전달하여 검색 횟수를 줄인다. 예) 첫 배열에서 찾은 값 → 다음 배열에서 시작 지점으로 활용.

2. 구현 방식

: 상위 레벨의 모든 요소 중 일부(가장 근접한 요소)를 하위 레벨에 미리 연결해둔다.
하위 레벨 배열에서 별도 탐색 없이 상위 레벨의 인덱스를 참고해 검색 가능하다. 이를 통해 검색 시간 단축 + 캐시 효율 증가 → 탐색 비용 감소.

브리지를 따라 연결된 배열 구조를 통해 상위 레벨에서 검색한 위치 정보를 하위 배열로 넘긴다. 이를 통해 탐색 시 하위 배열에서 처음부터 다시 검색할 필요 없이 빠르게 접근 가능하다.

-> 결과적으로 탐색 횟수 및 메모리 공간 절약 효과가 있다.

### 9) 로그 배열

: FD-트리는 로그 구조로 배열을 구성한다. 새로운 데이터가 들어올 때마다 가장 최신 배열(L1)에 먼저 기록한다.
기존 데이터와 충돌 시, 새로운 버전이 위쪽에 위치하고, 하위 배열엔 오래된 값이 존재한다. 필요 시, 여러 배열을 병합하여 새로운 배열로 정리한다.
이 구조는 LSM 트리와 유사하며, 읽기 효율을 위해 병합 주기 및 크기 관리가 필요하다.

### 10) 정렬된 배열 접근 방식

: 탐색을 위해 각 배열이 정렬되어 있다. 상위 레벨 배열의 요소 포인터를 하위 배열에 연결하여 검색 효율을 높인다.

중복된 키가 여러 레벨에 존재할 수 있으며, FD-트리는 최신 값을 찾기 위해 상위 배열부터 탐색한다. 삭제된 키를 처리하기 위해 툼스톤을 사용한다.
하위 배열에 같은 키가 있어도 무시된다. 툼스톤이 하위 배열에 남지 않도록 나중에 병합을 통해 제거한다.
