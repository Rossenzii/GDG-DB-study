### 1) Bw-트리
쓰기 증폭: update를 위한 공간을 미리 확보할떄 발생함

i) 연속된 B-트리 페이지 수정으로 인해 disk에 저장된 페이지 원본을 모든 요청마다 update해야할 수도 있음

ii)동시성 문제와 래치 사용의 복잡성

Buzzword 트리: 한번의 CAS 연산으로 노드 사이를 연결하는 포인터를 생성할 수 있는 in-memory 자료 구조를 사용해서 잠금이 필요없는 트리

### 2) 체인 업데이트

BW-트리: 변경 사항과 원본 노드를 따로 저장함 변경 사항은 체인을 형성함 

-> 따로 저장해서 디스크에 저장된 원본 노드를 수정하지 않아도 됨

- 해결 전략: 

i) 추가 전용 스토리지 사용 (immutable + append-only). 업데이트는 델타 노드로 기록

ii) CAS 연산으로 포인터만 교체하여 래치 없이 구조 변경

iii) 불변 데이터 구조(immutable) 사용 → 쓰는 도중에도 읽기 가능

- 체인 업데이트 방식:

변경 사항은 델타 노드에 쌓음 (기존 원본 노드는 변경하지 않음) -> 델타는 삽입, 삭제, 갱신 모두 포함 가능

필요 시 통합을 통해 새로운 base 노드 생성

### 3) CAS 연산으로 동시성 문제 해결

각 논리적 노드는: 하나의 base 노드 + 여러 개의 delta 노드, 매핑 테이블에 논리적 주소 → 물리적 주소 매핑

읽기/쓰기 전환 시 CAS(compare-and-swap) 사용 -> 기존 포인터가 예상값이면 갱신, 아니면 실패하고 재시도

- 읽기 흐름: 루트부터 리프까지 따라가면서 base + 최신 델타 찾음 -> 델타 노드 새로 생성 -> CAS로 포인터 업데이트

### 4) 구조 변경 작업
구조 변경 필요성: 노드가 너무 커지거나 작아져서 분할 또는 병합필요

- 분할 과정: 

i) 특수한 분할 델타를 덧붙임

ii) 형제 포인터로 new 노드를 연결

iii) 리더는 split 노드를 통해서만 new 노드에 접근 가능

iv) 부모 노드 포인터 업데이트 시 분할 완료됨

(이 단계 전까지는 불완전한 SMO 상태)

- 병합 과정 단계

형제 노드 제거: 삭제될 노드를 의미하는 remove delta 추가.

병합 delta 추가: 오른쪽 형제 노드를 가리키는 병합 delta를 왼쪽 노드에 추가.

부모 포인터 업데이트: 부모 노드에서 해당 자식 포인터를 삭제하여 병합 완료.

- 중간 상태 처리

중지 델타를 통해 동시성 이슈 방지, 루트 노드 분할 시, Bw-트리의 높이 증가, 루트 노드가 커지면 새 루트 노드 생성


### 5) 노드 통합과 가비지 컬렉션

- 이유: 델타 체인이 너무 길어지면 읽기 성능 악화, 읽기 비용 증가 및 공간 낭비 -> 통합 필요

- 방식: 원본 노드 + 델타 노드 통합 -> 새 base 노드 생성

새 노드는 새 위치에 저장되며, 매핑 테이블 갱신, 이후 기존 체인은 제거 (가비지 컬렉션)

LLAMA, 로그 구조 스토리지와 연관: 쓰기 효율성을 위한 가비지 컬렉션과 메모리 관리 전략 포함

- 메모리 해제 방식: 에포크 기반 가비지 수집 (사용 중인 리더가 없는 시점에만 노드 제거 가능)

동시성 있는 쓰기 시스템에서 잠금 없이 안전하게 삭제할 수 있게 해줌


### 6) 캐시 비인지형 B-트리

: 특정 캐시 크기나 페이지 크기를 알지 않고도 최적 성능을 보장 -> 메모리 계층의 파라미터 없이, 모든 레벨에서 효율적인 접근 가능

- 특징
i) cache-line 크기, 파일 시스템 블록 크기, 디스크 페이지 크기 등에 독립적

ii) 페이지 캐시를 의식하지 않아도 효율적으로 작동

iii) 메모리-디스크 간 I/O 최소화


### 7) 엠데 보아스(VEB) 레이아웃
: 정적 B-트리를 반 엠데 보아스 방식으로 메모리에 패킹

서브트리를 재귀적으로 분할하여 연속된 메모리 블록에 저장, 패킹된 배열로 구성 -> 메모리 지역성 극대화

삽입/삭제 시: 재배치가 필요할 수 있음 -> 갭을 두거나 밀도 기준에 따라 재구성 필요
