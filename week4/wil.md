# [파일 포맷]

## 소개

1. 디스크 접근 방식: 시스템 호출(read, write)을 통해 접근이 이루어짐 

→ 대상 파일내의 offset을 직접 지정 & 디스크 상의 표현을 메인 메모리에서 읽을 수 있는 형태로 변환(파싱 / 역직렬화)해야 함

2. 메인 메모리 접근 방식: 가상 메모리를 사용하면 개발자가 offset을 직접 지정하지 않아도 메모리 주소로 접근 가능.

3. 포인터 관리: 디스크 기반 B-트리는 메모리 주소가 아닌 '페이지 번호 + 오프셋'으로 포인터를 구현함

## 파일 포맷의 중요성

1. 파일 포맷 설계: 메모리 모델이 메모리를 알아서 관리해야하는 프로그래밍 언어로 자료 구조를 설계하는 것과 유사함

즉, 바이트 단위로 직접 레이아웃 설계하고 할당/참조 방식까지 정해야 함.

2. 비관리형 프로그래밍 언어: 연속된 memory segment 존재 여부, memory fragmentation 여부, 메모리 해제 이후의 상황은 신경쓰지 않음

디스크에서는 Garbage Collection이 없음 

→ 데이터를 쓰고 나면 직접 삭제하거나, 삭제 마크(flag)를 설정하거나, 재사용 구조를 만들어야 함

3. 데이터 블록 사용: 
→ 고정 크기의 자료형 또는 구조체를 기반으로 블록 단위로 데이터를 쪼개어 저장
→ 블록 안에서 포인터(=offset, 페이지 번호 등)로 큰 데이터를 참조하는 방식 사용

4. 데이터를 메인 메모리에 저장할 시.. : 메모리 layout과 관련된 문제가 발생하지 않거나 third party library로 해결할 수 있음

## 바이너리 인코딩

1. 바이너리 인코딩의 목적 → 데이터를 컴팩트하게 저장하고, 빠르게 직렬화/역직렬화할 수 있도록 하는 것

→ JSON이나 XML보다 훨씬 효율적

2. 디스크 접근은 read/write만 가능
→ malloc, free처럼 메모리 주소를 조작하는 방식은 사용할 수 없음

## 기본형

1. 키/값 자료형: 정수, 문자열, 날짜, 불리언 등

고정 길이 자료형: 대부분 정수형은 고정된 바이트 수 (예: int = 4byte)

멀티 바이트 숫자형: 바이트 순서(endian)가 중요함

2. 엔디언: 바이트 배열 순서를 정의함

빅 엔디언: 최상위 바이트부터 시작해서 내림차순으로 저장함 (MSB를 가장 낮은 주소에 저장), 네트워크 전송 시 사용하는 방식임

리틀 엔디언: 최하위 바이트부터 높은 자리 바이트까지 오름차순으로 저장함

3. 레코드: 숫자, 문자열, 불리언과 같은 기본형과 이들의 조합으로 구성됨
바이트 시퀀스 형태로 네트워크를 통해 전송되고 디스크에 저장됨 → 전송 및 쓰기 전에 우선 직렬화 & 수신 및 읽기 전에 역직렬화해야 함

직렬화: 객체 → 바이트 시퀀스로 변환

역직렬화: 바이트 → 객체 복원

기본형 데이터 → 바이너리 형식으로 표현하는 방법)

4. 부동 소수점: 부호, 가수, 지수로 구성됨, 가수를 사용하기 떄문에 결괏값이 근갓값임

## 문자열과 가변 길이 데이터

모든 기본형 데이터의 크기는 고정됨

더 복잡한 자료 구조: struct처럼 여러 기본형 값을 조합해 하나의 자료구조로 만들고 고정 길이 배열 or 포인터로 다른 메모리 영역을 참조함

1. 문자열과 가변 길이 자료형: 배열의 크기 or 문자열의 길이를 나타내는 숫자 & size 바이트 크기의 실제 데이터로 구성됨 → 파스칼 문자열이라고 부름

파스칼 문자열: 내용을 확인하지 않고 길이를 상수 시간 안에 알 수 있음, 메모리에서 size 바이트만큼 자른 byte 배열을 문자열 생성자에 전달 → 언어별 문자열 구성, [길이 바이트][문자열]

파스칼 문자열의 대안: 널 종단 문자열, 즉, byte 단위로 문자열 끝 기호에 도달할 때까지 읽음, [문자열][0x00]

## 비트 묶음형 데이터: boolean, enum, flag

1. boolean: 단일 바이트, 8개의 boolean 값이 각 1비트씩 사용하도록 묶기도 함

2. enum: 바이너리 포맷, 통신 protocol에 사용함

3. flag: 묶음형 boolean & enum의 조합, 페이지의 값 보유 여부 or 특정 값 크기의 고정 또는 가변 여부, 특정 노드의 페이지에 overflow 발생 여부를 나타낼 때 사용

bitmask or bit 연산자를 사용해 값을 묶어서 표현할 수 있음 ex) 특정 flag의 bit를 설정할 시 or 연산자, bitmask 사용함 bit 해제 시 and 연산자, ~ 사용함 

int FLAG_READ = 0x01;      // 0001
int FLAG_WRITE = 0x02;     // 0010
int FLAG_EXECUTE = 0x04;   // 0100

int permission = FLAG_READ | FLAG_EXECUTE; // 0101

// 특정 플래그 확인
if ((permission & FLAG_WRITE) != 0) {...}

// 플래그 해제
permission = permission & ~FLAG_READ;


## 파일 포맷 설계 원칙

1. 주소 지정 방식
: 데이터를 어떻게 참조할지부터 결정해야 함 (포인터 대신 오프셋)

2. 페이지 분할 여부
: 파일을 고정 크기의 블록 or 페이지(Page) 단위로 나눌지 결정
In-place update를 지원하려면 고정 페이지 크기가 유리함 (읽기&쓰기 편함) 예) B-트리에서 각 노드는 페이지 하나로 구성됨

3. 헤더와 트레일러
헤더: 파일의 메타 정보 (버전, 포맷, 전체 크기 등)
트레일러: 인덱스, 체크섬, 정리 정보 등
파일의 일부분만 읽고도 전체 구조 파악 가능하게 도와줌

4. 고정된 스키마 활용
각 위치(필드, 셀 등)의 크기가 고정되면 파싱이 빠르고 저장 공간이 절약됨

5. 파일의 계층적 구조
파일
 └── 리전 (Region)
      └── 섹션 (Section)
           └── 페이지 (Page)
                └── 셀 (Cell)
                     └── 필드 (Field)


필드: 실제 저장되는 단위 (int, string 등)
셀: 필드들의 묶음 → 하나의 row
페이지: 셀들의 묶음 → 디스크 I/O 단위 (ex. 4KB)
섹션/리전: 여러 페이지를 묶은 단위 (범용성 향상)

디코딩을 위해 필요한 오프셋 정보는: 헤더, 트레일러, 혹은 각 셀 내부에 위치