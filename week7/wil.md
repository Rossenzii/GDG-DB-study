## 리밸런싱
: 일부 B-트리에서 분할/병합 시 발생하는 구조적 불균형을 해소하기 위해 레벨 내에서 노드를 리밸런싱한다.
-> 노드의 점유율을 높이고 트리의 높이를 낮춘다

1) 노드 분할: 삽입 시 노드가 꽉 차면, 중간 키를 위로 올리고 노드를 둘로 나눔.
이 과정이 반복되면 트리의 높이가 증가할 수 있음.

2) 노드 병합: 삭제 시 노드가 너무 비게 되면, 형제 노드와 병합하여 최소 키 조건을 만족시킴.
이때도 부모 노드에서 키를 하나 제거하므로 트리의 높이가 줄어들 수 있음.

3) 노드 재분배 / 리밸런싱: 노드 분할이나 병합을 피하기 위해, 형제 노드와 원소를 일부 교환하여 키 수를 조정함.
예: 왼쪽 노드는 가득 차 있고, 오른쪽 노드는 여유가 있다면 → 일부 키를 오른쪽으로 옮겨 공간 확보

- B*-트리 vs B-트리
노드 분할 시기: B-트리는 노드가 가득 차면 즉시 분할하고 B*-트리는 형제 노드에 여유가 있으면 재분배 후 분할 지연함
분할 방식: B-트리는 1개 노드를 2개 노드로 나누고 B*-트리는 2개 노드를 3개로 나눔
트리 높이: B-트리는 상대적으로 높아질 수 있고 B*-트리는 높이가 더 낮다
속도: B-트리는 검색 시 디스크 접근이 더 많을 수도 있고 B*-트리는 페이지 수가 적어 빠름

노드 점유율이 높아지면 
-> 같은 데이터를 더 적은 노드에 담을 수 있음
-> 전체 트리 높이도 낮아짐
-> 검색 시 더 적은 디스크 I/O로 원하는 데이터를 찾을 수 있음

## 오른쪽 추가 기법
:새 데이터를 삽입할 때, 가능하다면 오른쪽 형제 노드에 우선적으로 추가한다.
목적: 트리 구조상 오른쪽 형제 노드가 더 큰 값을 저장하는 경향이 있음
왼쪽보다 오른쪽에 새 데이터를 넣는 것이 정렬 유지에 유리함 (분할 시 루트까지의 전파를 줄일 수 있음)

동작: 삽입하는 키가 가장 오른쪽 페이지의 첫 번째 키보다 크고 가장 오른쪽 페이지에 새로운 키를 삽입할 공간이 있다면 탐색 과정을 건너뛰고 캐시된 페이지의 알맞은 위치에 키를 삽입
postgresql에서는 이를 fastpath라고 부름

## 벌크 로딩
: 수백만 건의 데이터를 한꺼번에 DB에 삽입하는데 최적화된 입력 방법
동작: 
1) 트리의 하위 레벨 -> 상향식으로 한 레벨씩 구성하거나 상위 레벨 노드에 충분한 수의 포인터를 넣을 수 있을 만큼 하위 레벨 노드가 추가됐을 때 상위 노드를 쓴다.
정렬된 데이터를 리프 노드부터 채움 -> 리프 페이지가 다 차면 → 그 리프의 첫 번째 키를 부모 노드에 넣음 
-> 부모 노드도 마찬가지로 자식 포인터를 가질 수 있을 만큼 차면, 그 위에 부모를 또 만든다
이런 식으로 리프 → 내부 노드 → 루트까지 위로 올라가면서 트리를 만든다
2) 미리 정렬된 데이터를 리프 레벨에 페이지 단위로 저장한다. (리프 페리지 생성 -> 리프 페이지의 첫 번째 키를 부모 노드에 복사하고 상위 레벨은 B-트리 알고리즘으로 구성)
ex) 100만 개의 정렬된 키 존재, 한 페이지에 100개 저장한다.
10,000개의 리프 노드가 만들어짐, 리프 노드는 페이지 단위로 만들어지고 → 그 리프의 첫 키를 부모 노드에 올림.
(이때 오른쪽 추가 기법 사용)

## 압축 
: 저장 공간을 절약하고 I/O 속도 개선한다. → 더 작은 데이터로 더 많은 내용을 한 번에 읽을 수 있음
특징:
1) 압축률이 높을수록 데이터 크기 감소 (한번에 더 많은 데이터를 읽음, but 압축&해제 작업에 더 많은 RAM, CPU 사이클 사용)
2) 페이지 단위 압축이 좋다: 디스크 I/O 단위 = 압축 단위 = 메모리 캐시 단위 / ➜ 정렬되고 일관된 데이터 접근, 캐시 효율 ↑
row/column 단위로 압축하면, 압축/해제 시점과 페이지 단위 I/O가 따로 움직임
ex) 압축된 row 하나만 풀기 위해 전체 페이지를 불러오거나,여러 row가 하나의 압축 blob에 있으면 해제하는 데 시간이 더 걸림
3) 데이터 셋이 클수록 작은 압축 단위가 적합함
데이터가 커질수록, 전체를 한꺼번에 압축하면 -> 해제 시 CPU 과부하 발생 & 랜덤 액세스 시 성능 저하
작은 단위로 압축하면 필요한 일부만 압축 해제 가능
4) 블록 전송 단위의 비효율: 디스크에서 블록 단위로 데이터 전송 (ex. 4KB)
그런데 압축된 페이지가 너무 작으면 블록 하나에 여러 페이지가 들어가 버릴 수 있음
: 한 페이지만 필요한데 전체 블록(더 큰 용량)을 불러와야 해서 실제 읽는 byte 수가 더 많아짐 -> I/O 낭비 초래
5) 메모리 오버헤드, 압축/해제 성능, 압축률을 고려해서 라이브러리를 선택

## 정리와 유지
: 데이터를 계속 삽입·삭제·수정하다 보면 페이지 단편화, 공간 낭비, 검색 성능 저하가 생기게 됨
-> 이를 해결하기 위해 정리(compaction), 정렬, 정비 작업을 백그라운드에서 자동으로 수행하기도 함
1) 오버헤드 최소화: 시스템이 느려지지 않도록 정리 작업을 백그라운드에서 수행함 + 후처리 비용 감소
2) 슬롯페이지: 한 페이지 내에서 row의 위치를 슬롯(인덱스) 방식으로 관리하는 구조
삽입/삭제가 반복되면 → 슬롯만 갱신하기 때문에 효율적
but, 리프 페이지에 너무 많은 삭제, 갱신이 일어나면 -> 단편화 발생 & 내부 노드 분할/병합 시에도 불필요한 공간 낭비
3) B-트리: 항상 루트 노드에서부터 탐색해서 데이터를 찾음 -> 어디에서 어떤 데이터에 도달 가능한지가 중요함
라이브 상태: 루트에서부터 탐색 가능한 경로를 통해 접근 가능한 데이터
가비지: 루트에서 탐색할 수 없는 죽은 노드나 데이터 -> 이미 삭제되었지만 여전히 페이지에 남아 있음, 클린업이 필요함

## 업데이트&삭제로 인한 단편화
B-Tree 기반의 저장소(SQLite, PostgreSQL 등)에서는 데이터를 페이지 단위로 저장하고 삽입, 삭제, 갱신이 반복 -> 단편화 발생
이 단편화를 줄이기 위해 가비지 컬렉션 수행
1) 가비지 데이터가 존재하는 페이지를 컴팩션하는 방법: 삭제된 리프 레벨의 셀은 헤더에서 오프셋만 제거하고 실제 셀은 남긴다
삭제해도 진짜 데이터를 바로 지우진 않고 페이지 헤더(인덱스 목록)에서 표시만 해둔다. (쿼리 불가능해짐, )
데이터는 메모리에 그대로 있음 (= 가비지)
-> 쿼리 불가능해짐
2) 헤더에서 빠진 셀은 나중에 새로운 삽입으로 덮어쓰거나 시간이 지나면 가비지 컬렉터가 삭제함
3) 멀티 버전 동시성 제어: 여러 트랜잭션이 동시에 데이터에 접근할 수 있게 하기 위해 어떤 트랜잭션이 그 셀을 보고 있을 수 있으니 즉시 삭제는 금지
누군가 아직 SELECT 중이라면 해당 데이터는 지우지 않고 남겨둔다.
모든 트랜잭션이 해당 셀을 더 이상 보지 않게 되면 가비지 컬렉터가 삭제함
4) 단편화: 삭제한 데이터를 진짜 삭제 안 하고 그냥 비워둬서 페이지 내부에 공간이 군데군데 흩어지는 현상
5) B-Tree 내부 노드의 키는 경로 안내자 역할 (직접 값 없음) -> 리프 페이지에서 진짜 데이터를 찾음
데이터 값 자체는 리프 노드에 있어서 갱신은 리프에서 수행

## 페이지 단편화
컴팩션: 페이지 별로 가비지 컬렉션을 수행하고 데이터를 재작성하는 독립적인 비동기적 과정
1) 데드 셀이 차지하는 공간을 회수하고 셀을 논리적 순서로 재정렬
2) 사용 중이지 않은 in-memory page는 사용 가능 상태로 변경되고 페이지 캐시에 반환됨, 디스크에 새로 할당된 페이지의 id는 free page list에 추가