### 1) 읽기, 쓰기, 메모리 증폭

읽기 증폭: 데이터를 읽기 위해 여러 테이블을 탐색할 때 발생

쓰기 증폭: 컴팩션 시 동일 데이터를 여러 번 재작성할 때 발생

공간 증폭: 동일 키에 대해 중복 레코드가 존재할 때 발생

### 2) RUM 예측

RUM: Read, Update, Memory 오버헤드를 기준으로 스토리지 비용을 계산하는 모델임

세 가지 요소 중 두 개를 줄이면 나머지 하나의 오버헤드가 커짐(트레이드 오프 관계).

목표: 낮은 메모리와 쓰기 오버헤드 유지하면서 읽기 비용을 최소화하기

현실적으로 세 요소를 모두 최소화하는 것은 불가능함

-> latency, 구현 복잡도 고려 X

B-트리: 디스크에서 레코드를 찾아 연속적으로 쓰기 -> **쓰기 증폭 발생**, 공간과 삭제 공간 오버헤드가 발생함

LSM 트리: 디스크에 순차적으로 쓰기 -> 쓰기 효율 올라가지만 읽기 시 여러 테이블 참조 → **읽기 증폭 발생**

LSM은 중복 데이터로 인한 메모리 오버헤드가 존재함

### 3) LSM 트리 구현 세부 설명

주요 요소: 읽기, 쓰기, 컴팩션, 세컨더리 인덱스, 디스크 테이블 참조 최소화 방법, 로그 구조 스토리지

**디스크 기반 테이블** : SSTable 사용해 구현, 키 순서로 정렬, 불변, 인덱스 파일과 데이터 파일로 구성됨, 한 번 생성되면 수정 불가 -> 컴팩션 시 병합함

**SSTable 첨부형 보조 인덱스**

ex) 카산드라에서 SSTable과 함께 별도 인덱스 생성

목적: LSM의 읽기 증폭 감소

인덱스는 메모리/디스크에 저장되며 병합 시 새로 생성함


### 4) 블룸 필터
: **특정 키 존재 여부**를 빠르게 확인하여 불필요한 디스크 접근 방지함

- 특징: 확률적 자료구조 -> 오탐(false-positive) 가능, 누락(false-negative) 없음

여러 해시 함수 사용, 큰 비트 배열로 구현함

배열 크기와 해시 함수 수에 따라 정확도와 메모리 사용량을 결정함

LSM에서 다수 테이블을 확인하는 오버헤드를 완화함

- 예시

모든 해시 결과 비트가 1이면 존재할 가능성 있음으로 판정, 하나라도 0이면 존재하지 않음으로 판정

예시) key3 해시 결과 -> 일부 비트가 이미 설정돼 있어 실제로는 없는 키도 존재하는 것처럼 보일 수 있음(오탐).

### 5) 스킵 리스트

- 특징: 데이터를 정렬된 상태로 유지하며 연결 리스트에 여러 수준 인덱스를 부여해 탐색 효율을 향상함

각 노드는 여러 개의 포인터를 가질 수 있으며, 높은 레벨일수록 적은 수의 노드만 연결됨

- 탐색 과정 예시

최상위 레벨 포인터로 탐색 시작 -> 키 비교 후 작거나 크면 해당 방향으로 이동함 -> 조건 불만족 시 한 레벨 내려가 탐색함

삽입/삭제: 트리처럼 균형 유지 불필요, 확률적으로 레벨을 결정함

장점: 구현 간단, 메모리 효율적, 일부 인메모리 인덱스 구현에 사용됨

### 6) 디스크 접근

LSM 트리의 테이블 데이터 대부분은 디스크에 저장함

**차이점**:
인메모리 데이터는 수정이 불가함 -> 접근 시 잠금·캐시가 필요 없음

LSM 레코드는 페이지·오프셋 기반이 아니라 절대 오프셋 기반 참조가 가능함


일부 레코드는 페이지 경계를 넘을 수 있음 -> 여러 페이지 읽기가 필요함 

(LSM 트리에서도 특정 레코드를 읽을 때 페이지 1개만 읽는 게 아니라, 걸쳐 있으면 여러 페이지를 읽어야 한다는 것)

**절대 오프셋 기반 참조**

1)B-Tree 구조에서는 페이지 번호 + 오프셋 방식으로 데이터를 찾아감 예) Page 42, Offset 128

2)LSM 트리에서는 SSTable(정렬된 테이블 파일)이 디스크에 순차적으로 저장되므로, 파일의 절대 오프셋(byte 위치)로 바로 접근할 수 있음

예: 파일의 2,345번째 바이트 위치에서 시작

-> 디스크 탐색 과정이 단순해지고 I/O를 줄일 수 있다. 

### 7) 압축

LSM 테이블은 불변 구조이므로 페이지 단위 압축이 가능함

압축 페이지는 원본 페이지보다 작아 페이지와 정렬되지 않을 수 있음

접근 시 오프셋·크기 메타데이터를 사용해 압축을 해제함

장점: 저장 공간 절약, 읽기 성능 유지

### 8) 비정렬 LSM 스토리지

대부분의 스토리지는 정렬된 데이터 구조 사용(B-트리, FD-트리, SSTable).

비정렬 구조: 레코드를 순서 보장 없이 삽입 순서대로 저장함, 별도 로그 불필요, 단순 쓰기 효율이 좋음, 조회나 정렬이 필요한 경우 추가 비용 발생함

